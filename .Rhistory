filter(year == myYear) %>%
distinct(team, driver)
sumLapByDriverTeam = lbl %>%
filter(year == myYear & isGood30) %>%
group_by(team, driver) %>%
summarise(numLap = n()) %>%
ungroup() %>%
complete(allTeamDriver, fill = list(numLap = 0))
tmPairing = tmPairing %>%
left_join(sumLapByDriverTeam %>%
rename(driver1 = driver,
numLap1 = numLap),
c('team', 'driver1')) %>%
left_join(sumLapByDriverTeam %>%
rename(driver2 = driver,
numLap2 = numLap),
c('team', 'driver2'))
# now ditch non driving drivers
tmPairing = tmPairing %>%
filter(numLap1 > 0 & numLap2 > 0) %>%
select(-c(numLap1, numLap2))
compCol = c('all', 'minusCarProb', 'minusTraffic', 'minusDeadRubber', 'fuelAdj', 'meanTyreLap1', 'meanTyreLap2')
tmPairing[,compCol] = NA
for (ti in 1:nrow(tmPairing)) {
rawOutput = with(tmPairing[ti,], CheckTwo(myYear, driver1, driver2, team))
tmPairing[ti, compCol] = CoerceComparisonToList(rawOutput)
}
return(tmPairing)
}
ViewComparisonByYear(2014)
ViewComparisonByYear(2012)
ViewComparisonByYear(2011)
source('c:/research/f1/f1-startup.r')
newVersionIsLive = TRUE
source('c:/research/git/f1-startup.r')
source('c:/git/f1-startup.r')
source('c:/git/f1/f1-startup.r')
newVersionIsLive = TRUE
source(paste0(UPDATECODEPATH, 'fetch-data.r'))
source(paste0(UPDATECODEPATH, 'augment-raw-data.r'))
source(paste0(UPDATECODEPATH, 'transfer-data-to-database.r'))
myYear = 2019
FetchSeasonInfo(myYear)
YRDIRTOUSE = paste0(OUTPUTPATH, 'data/', myYear)
YRDIRTOUSE
dir.exists(YRDIRTOUSE)
YRDIRTOUSE = paste0(OUTPUTPATH, myYear)
dir.exists(YRDIRTOUSE)
dircheckmake(YRDIRTOUSE)
HTMLYRDIRTOUSE = paste0(HTMLPATH, myYear)
HTMLYRDIRTOUSE
dir.exists(HTMLYRDIRTOUSE)
HTMLPATH
HTMLYRDIRTOUSE = paste0(HTMLPATH, myYear)
dir.exists(HTMLYRDIRTOUSE)
dircheckmake(HTMLYRDIRTOUSE)
raceDF = FetchSeasonInfoFromForix(myYear, YRDIRTOUSE)
if (FALSE) {
if (!newVersionIsLive) {
fromfile = paste0('c:/research/f1/temporary transfer data/covsh_clean_',myYear,'.csv')
tofile = MakeYearFile(myYear, 'raceDF.csv')
b = read_csv(fromfile) %>%
dplyr::rename(totalDistance = totdist,
htmlName = htmlname,
race = racename)
write_csv(x = b, path = tofile)
raceDF = ReadF1Data(MakeYearFile(myYear, 'raceDF.csv'), 'raceDF')
fromfile = paste0('c:/research/f1/temporary transfer data/drivertla-override_', myYear, '.csv')
b=read.csv(fromfile) %>%
dplyr::rename(race = racename)
tofile = paste0(YRDIRTOUSE, '/drivertla-override.csv')
write_csv(x = b, path = tofile)
}
}
InitialiseYearlyDirectory(YRDIRTOUSE, HTMLYRDIRTOUSE, raceDF)
rawDataStatus = GetRawDataStatus(myYear)
rawDataStatus
# of course, not all races will have happened yet, but will deal with that later
raceToGet = FindRaceToGet(raceDF, rawDataStatus)
raceToGet
dum = CompileWebAndFileAddress(raceToGet, raceDF, myYear)
pagedf = dum$pagedf
filedf = dum$filedf
filedf
# now get the web pages
for (ri in 1:length(raceToGet)) {
visitsave(webpagelist = unlist(pagedf[ri, ]),
thiscomputer = thiscomputer,
filenamelist = MakeHtmlRaceFile(raceToGet[ri], filedf$file))
}
if (FALSE) {
if (!newVersionIsLive) {
haveGapsChart = f1admin::CheckYearAttribute(myYear, 'haveGapsChart')
haveArchivedLapTimeCsv = f1admin::CheckYearAttribute(myYear, 'haveArchivedLapTimeCsv')
if (!haveGapsChart & haveArchivedLapTimeCsv) {
TransferArchivedLapTimeCsv(myYear)
}
}
### NB just copy them from where we've already got them obviously
if (FALSE) {
if (!newVersionIsLive) {
print('Disable this section of code once new version is live!')
for (ri in 1:length(raceToGet)) {
tofile = MakeHtmlRaceFile(raceToGet[ri], filedf$file)
fromfile = gsub('/f1/', '/lapbylap/', tofile)
for (j in 1:length(tofile)) file.copy(fromfile[j], tofile[j], overwrite = TRUE)
}
}
}
}
for (ri in 1:length(raceToGet)) {
entryDF = StripEntryEtc(raceToGet[ri])
}
for (ri in 1:length(raceToGet)) {
entryDF = ReadF1Data(MakeRaceFile(raceToGet[ri], 'entryetc.csv'), 'entryDF')
myHtmlName = with(raceDF, htmlName[race == raceToGet[ri]])
FetchDriverRacePage(raceToGet[ri], entryDF, myHtmlName)
}
for (ri in 1:length(raceToGet)) {
entryDF = ReadF1Data(MakeRaceFile(raceToGet[ri], 'entryetc.csv'), 'entryDF')
StripPitStop(raceToGet[ri], entryDF)
StripLapTime(raceToGet[ri])
StripTyreSpeedtrap(raceToGet[ri])
rawDataStatus$fetched[rawDataStatus$race == raceToGet[ri]] = TRUE
}
entryDF = ReadF1Data(MakeRaceFile(raceToGet[ri], 'entryetc.csv'), 'entryDF')
entryDF
source(paste0(UPDATECODEPATH, 'fetch-data-funct.r'))
for (ri in 1:length(raceToGet)) {
entryDF = ReadF1Data(MakeRaceFile(raceToGet[ri], 'entryetc.csv'), 'entryDF')
StripPitStop(raceToGet[ri], entryDF)
StripLapTime(raceToGet[ri])
StripTyreSpeedtrap(raceToGet[ri])
rawDataStatus$fetched[rawDataStatus$race == raceToGet[ri]] = TRUE
}
rawDataStatus
UpdateRawDataStatus(myYear, rawDataStatus)
AugmentRawData(myYear)
source(paste0(UPDATECODEPATH, 'augment-raw-data-funct.r'))
source(paste0(UPDATECODEPATH, 'augment-raw-data-funct.r'))
source(paste0(UPDATECODEPATH, 'reshape-raw-data-funct.r'))
AugmentRawData(myYear)
TransferDataToDatabase(myYear)
source('c:/research/f1/f1-startup.r')
source('c:/git/f1/f1-startup.r')
f1qualifying::RunQualifyingOutlier()
f1qualifying::RunQualifyingModel()
# also, do we need driverteam in the function, how about use driverTeamYr which has already been made
# worth checking the optimisation is ok, it looked a bit flat when run on very small sample of data
SmoothAndStretch('qual')
source('c:/git/f1/f1-startup.r')
f1qualifying::RunQualifyingOutlier()
f1qualifying::RunQualifyingModel()
# also, do we need driverteam in the function, how about use driverTeamYr which has already been made
# worth checking the optimisation is ok, it looked a bit flat when run on very small sample of data
SmoothAndStretch('qual')
LoadAllData()
mostRecentRace = raceDF$race[nrace]
f1smoothing::RunModel(mostRecentRace,
filterList = list(modelChoice = modelChoice,
useStretch = FALSE,
qrToPredict = c('q', 'r')))
modelchoice = 'qual'
f1smoothing::RunModel(mostRecentRace,
filterList = list(modelChoice = modelChoice,
useStretch = FALSE,
qrToPredict = c('q', 'r')))
modelChoice = 'qual'
rm(modelchoice)
f1smoothing::RunModel(mostRecentRace,
filterList = list(modelChoice = modelChoice,
useStretch = FALSE,
qrToPredict = c('q', 'r')))
filterList = list(modelChoice = modelChoice,
useStretch = FALSE,
qrToPredict = c('q', 'r'))
### have we already prepared a file for this? if not, make it now
smoothModelFile = MakeRaceFile(myRace, 'smooth-model.csv')
filterCombo = f1smoothing:::GenerateCombo(filterList = filterList)
if (!file.exists(smoothModelFile)) {
allCombo = f1smoothing:::GenerateCombo(filterList = NULL)
allCombo$fileIsDone = FALSE
allCombo[, c('maxTheta', 'smoothCoef', 'sqDiff')] = NA
}
myRace = mostRecentRace
### have we already prepared a file for this? if not, make it now
smoothModelFile = MakeRaceFile(myRace, 'smooth-model.csv')
filterCombo = f1smoothing:::GenerateCombo(filterList = filterList)
if (!file.exists(smoothModelFile)) {
allCombo = f1smoothing:::GenerateCombo(filterList = NULL)
allCombo$fileIsDone = FALSE
allCombo[, c('maxTheta', 'smoothCoef', 'sqDiff')] = NA
}
if (file.exists(smoothModelFile)) {
allCombo = ReadF1Data(smoothModelFile, 'smoothing')
allCombo$fileIsDone = !is.na(allCombo$sqDiff)
}
## now filter down to the ones user has asked for (via filterList)
smoothParamName = f1smoothing:::GetSmoothParamName()
smoothModelChoiceComboName = c(smoothParamName, 'modelChoice')
allCombo = indicate_overlapping_combination(
allCombo,
filterCombo,
smoothModelChoiceComboName,
'isInFilter')
modelToRun = with(allCombo, which(isInFilter & !fileIsDone))
modelToRun
j=1
smoothOutput = f1smoothing:::GetSmooth(qrToFit = allCombo$qrToFit[j],
qrToPredict = allCombo$qrToPredict[j],
modelChoice = allCombo$modelChoice[j],
useStretch = allCombo$useStretch[j],
fwbw = allCombo$fwbw[j])
allCombo[j,]
debug(f1smoothing:::GetSmooth)
smoothOutput = f1smoothing:::GetSmooth(qrToFit = allCombo$qrToFit[j],
qrToPredict = allCombo$qrToPredict[j],
modelChoice = allCombo$modelChoice[j],
useStretch = allCombo$useStretch[j],
fwbw = allCombo$fwbw[j])
smoothOutput = f1smoothing:::GetSmooth(qrToFit = allCombo$qrToFit[j],
qrToPredict = allCombo$qrToPredict[j],
modelChoice = allCombo$modelChoice[j],
useStretch = allCombo$useStretch[j],
fwbw = allCombo$fwbw[j])
paste0('doneRawModel', whatToSmooth$modelChoice)
qrToFit= "q"
qrToPredict= "q"
useStretch= FALSE
fwbw= "bw"
smoothParam=list(qrToFit = qrToFit,
qrToPredict = qrToPredict,
useStretch = useStretch,
fwbw = fwbw)
smoothParamName = f1smoothing:::GetSmoothParamName()
f1smoothing:::DisplayChoice(smoothParam, modelChoice, customSmoothInfo)
cumstomSmoothInfo = NULL
modelChoice
smoothParam=list(qrToFit = qrToFit,
qrToPredict = qrToPredict,
useStretch = useStretch,
fwbw = fwbw)
smoothParamName = f1smoothing:::GetSmoothParamName()
f1smoothing:::DisplayChoice(smoothParam, modelChoice, customSmoothInfo)
customSmoothInfo = cumstomSmoothInfo
rm(cumstomSmoothInfo)
f1smoothing:::DisplayChoice(smoothParam, modelChoice, customSmoothInfo)
whatToSmooth = customSmoothInfo
whatToSmooth$modelChoice = modelChoice
### going to want to know this constantly, so define these variables just for brevity
smoothParam$useQual=smoothParam$qrToFit %in% c('q', 'qr')
smoothParam$useRace=smoothParam$qrToFit %in% c('r', 'qr')
f1smoothing:::CheckValidSmoothInfo(smoothParam, whatToSmooth)
whatToSmooth
names(raceDF)
devtools::install('model code/f1smoothing/')
devtools::install('model code/f1smoothing')
# this checks that the model has been run. could quite conceivably (in fact we do, when fitting model 4) be in situation where you want to smooth all the races but current model has not yet been fit.
rddf = f1smoothing:::DetectModelHasBeenRun(rddf, raceDF, whatToSmooth)
# this creates racePredNValid, raceDCoef, qualDCoef, stretch
rddf = f1smoothing:::MakeGeneralColumnName(rddf, smoothParam, whatToSmooth)
# this calculates when a driver/team/season has done any other races, whether they have a valid estimate today etc
rddf = f1smoothing:::DetectDriverHasOtherData(rddf, smoothParam)
rddf = f1smoothing:::MakePredNValidBin(rddf, smoothParam)
rddf = f1smoothing:::MakeNumobForPredict(rddf, smoothParam, whatToSmooth)
rddf = f1smoothing:::MakeQualRaceRescaleColumn(rddf, smoothParam)
rddf = f1smoothing:::PreSmoothRescaleDCoef(rddf, smoothParam)
OOSRddf = f1smoothing:::MakeOOSRddf(smoothParam, rddf)
dum = f1smoothing:::MakeDTFromTibble(rddf, OOSRddf, smoothParam)
raceDriverDT = dum$raceDriverDT
OOSRaceDriverDT = dum$OOSRaceDriverDT
QRRaceDriverDT = dum$QRRaceDriverDT
raceDriverDT = f1smoothing:::MakeIsPredValid(smoothParam, raceDriverDT)
if (smoothParam$qrToPredict %in% c('q', 'r')) {
pairedDriverDT = NULL
numFinisherByRace = NULL
}
if (smoothParam$qrToPredict == 'rfinpos') {
pairedDriverDT = f1smoothing:::MakePairedDriverDT(raceDriverDT)
numFinisherByRace = raceDriverDT[
!is.na(officialFinishingPosition) & hasOtherData,
.(numFinisher = .N),
'race']
}
DTList = list(raceDriverDT = raceDriverDT,
OOSRaceDriverDT = OOSRaceDriverDT,
QRRaceDriverDT = QRRaceDriverDT,
pairedDriverDT = pairedDriverDT,
numFinisherByRace = numFinisherByRace)
iterCount = 0
assign('iterCount', iterCount, env = globalenv())
maxTheta = f1smoothing:::RetrieveMaxTheta(smoothParam, whatToSmooth)
if (is.null(maxTheta) | resetMaxTheta) {
optParam = TRUE
}
if (!is.null(maxTheta) & !resetMaxTheta) {
optParam = FALSE
cat('Using previously saved parameter values for smoothing:\n')
f1smoothing:::InitialiseAndProcessCoef(maxTheta, smoothParam, display = TRUE)
}
resetMaxTheta = NULL
if (is.null(maxTheta) | resetMaxTheta) {
optParam = TRUE
}
resetMaxTheta = FALSE
maxTheta = f1smoothing:::RetrieveMaxTheta(smoothParam, whatToSmooth)
if (is.null(maxTheta) | resetMaxTheta) {
optParam = TRUE
}
if (!is.null(maxTheta) & !resetMaxTheta) {
optParam = FALSE
cat('Using previously saved parameter values for smoothing:\n')
f1smoothing:::InitialiseAndProcessCoef(maxTheta, smoothParam, display = TRUE)
}
if (optParam) {
maxTheta = f1smoothing:::OptimiseParam(smoothParam, DTList)
}
source('c:/git/f1/f1-startup.r')
f1qualifying::RunQualifyingOutlier()
f1qualifying::RunQualifyingModel()
# also, do we need driverteam in the function, how about use driverTeamYr which has already been made
# worth checking the optimisation is ok, it looked a bit flat when run on very small sample of data
SmoothAndStretch('qual')
f1outlier::GetOutlier0()
modelchoice = 4
f1validity::UpdateValidity(modelchoice)
f1laptimelm::ProcessLapTimeModel(modelchoice)
install.packages('numDeriv')
f1laptimelm::ProcessLapTimeModel(modelchoice)
CheckSensibleModel(4)
f1laptimelm::GetLapTimeLMIntercept(modelchoice)
### all checks are agreeing to desired level up to here...
SmoothAndStretch(modelchoice)
devtools::install('model code/f1smoothing')
### all checks are agreeing to desired level up to here...
SmoothAndStretch(modelchoice)
f1gaptrafficpitstop::ProcessInlapOutlapDelta()
f1gaptrafficpitstop::GetPostDeltaOvertaking()
f1carproblem::ProcessCarProblem()
# NB still got an issue: if you retrospectively declare a driver has a carproblem, then you need to update validity30 for that race, but this isn't yet happening
modelchoice = 30
f1validity::UpdateValidity(modelchoice)
f1laptimelm::ProcessLapTimeModel(modelchoice)
f1laptimelm::GetLapTimeLMIntercept(modelchoice)
SmoothAndStretch(modelchoice)
f1messystint:::ProcessInterruptedStint()
f1messystint:::ProcessGuessedPitStop()
f1messystint:::ProcessAlternativeStrategy()
f1messystint:::ProcessIntendedStopLap()
f1blockedovertakingmodel:::ProcessPossibleOvertaking()
f1blockedovertakingmodel:::ProcessBlockedOvertakingModel()
f1simulation:::ProcessInRunningWeightModel()
f1simulation:::ProcessSimulation()
install.packages('gridExtra')
sourceCpp(paste0(RCPPPATH, "simulate-overtaking.cpp"))
invlogit(3)
qlogis(3)
plogis(3)
plogis(-3)
invlogit(-3)
sourceCpp('c:/temp/test.cpp')
sourceCpp('c:/temp/test.cpp')
args(qlogis)
sourceCpp('c:/temp/test.cpp')
sourceCpp('c:/temp/test.cpp')
RcppInvlogit(3)
sourceCpp('c:/temp/test.cpp')
RcppInvlogit(3)
sourceCpp('c:/temp/test.cpp')
sourceCpp('c:/temp/test.cpp')
sourceCpp('c:/temp/test.cpp')
RcppInvlogit(3)
sourceCpp('c:/temp/test.cpp')
RcppInvlogit(3)
RcppInvlogit(3:5)
sourceCpp('c:/temp/test.cpp')
RcppInvlogit(3:5)
RcppInvlogit(2)
RcppInvlogit(-2)
RcppLogit(0.1192)
sourceCpp('c:/temp/test.cpp')
RcppLogit(0.1192)
sourceCpp('c:/temp/test.cpp')
RcppLogit(0.1192)
sourceCpp(paste0(RCPPPATH, "simulate-overtaking.cpp"))
sourceCpp(paste0(RCPPPATH, "driver-loop.cpp"))
sourceCpp(paste0(RCPPPATH, "driver-loop.cpp"))
sourceCpp('c:/temp/test.cpp', cacheDir = 'c:/temp')
ResetModelForRace('simulation', '2019abudhabi')
source('c:/git/f1/f1-startup.r')
f1simulation:::ProcessSimulation()
f1admin::UpdateDatabase()
f1plot::DriverRacePlot('2019japan','lhamilton','vbottas')
f1plot::DriverRacePlot('2019japan','lhamilton','vbottas', toFile = T)
f1data:::ViewLap('2019japan',40)
f1data:::ViewLap('2019japan',43)
f1data:::ViewLap('2019japan',42)
f1plot::DriverRacePlot('2019japan','cleclerc','svettel', toFile = T)
f1data:::ViewLap('2019japan',13)
f1data:::ViewLap('2019japan',1)
f1data:::ViewLap('2019japan',2)
f1data:::ViewLap('2019japan',3)
f1data:::ViewLap('2019japan',4)
f1plot:::RacePaceAndNumObPlot('2019mexico')
myRace = '2019mexico'
rddf = f1laptimelm::MakeNormDriverCoef(rddf, raceDF, 30, 'race')
carProblemDF = f1laptimelm::DeriveCarProblemCoef(carProblemDF, 30)
raceDF = f1data:::MakePrettyRaceLabel(raceDF)
myPaceDF = rddf %>%
filter(race == myRace & mod30PredNValid > 2) %>%
select(driver, team, mod30DCoef, mod30PredNValid) %>%
mutate(isCarProblem = FALSE)
myCarProbPaceDF = carProblemDF %>%
filter(race == myRace &
mod30PredNValid > 5 &
mod30DCoef < 5 &
isWholeRace) %>%
mutate(isCarProblem = TRUE) %>%
select(driver, mod30DCoef, mod30PredNValid, isCarProblem)
haveCarproblemDriver = nrow(myCarProbPaceDF) > 0
if (haveCarproblemDriver) {
myPaceDF = bind_rows(myPaceDF, myCarProbPaceDF)
}
myPaceDF = lazy_left_join(myPaceDF,
rddf %>%
filter(race == myRace),
'driver',
c('team', 'maxLap'))
myPaceDF = myPaceDF %>%
dplyr::rename(dcoef = mod30DCoef,
totalAvailable = maxLap,
totalCompleted = mod30PredNValid) %>%
mutate(dcoef = dcoef - min(dcoef)) %>%
arrange(-dcoef)
myPaceDF = f1plot:::.PaceNumObGetDriverSurname(myPaceDF)
myPaceDF = f1plot:::.PaceNumObGetDriverLabel(myPaceDF, 'race', haveCarproblemDriver)
myYear = with(raceDF, year[race == myRace])
myTitle = f1plot:::.PaceNumObGetPlotTitle(myRace = myRace, raceDF = raceDF)
gt = f1plot:::.PaceNumObMakeThePlot(myPaceDF, 'race', myYear, myTitle, haveCarproblemDriver)
myPaceDF
myCarProbPaceDF
myPaceDF = rddf %>%
filter(race == myRace & mod30PredNValid > 2) %>%
select(driver, team, mod30DCoef, mod30PredNValid) %>%
mutate(isCarProblem = FALSE)
myCarProbPaceDF = carProblemDF %>%
filter(race == myRace &
mod30PredNValid > 5 &
mod30DCoef < 5 &
isWholeRace) %>%
mutate(isCarProblem = TRUE) %>%
select(driver, mod30DCoef, mod30PredNValid, isCarProblem)
myPaceDF
anti_join(myPaceDF, myCarProbPaceDF, 'driver')
devtools::load_all('f1plot')
RacePaceAndNumObPlot('2019mexico')
f1plot::StintSummary('2019mexico')
f1data:::ViewLap('2019mexico', 10)
f1data:::ViewLap('2019mexico', 15)
f1data:::ViewLap('2019mexico', 22)
f1data:::ViewLap('2019mexico', 30)
raceTyreDF %>% filter(race == '2019mexico')
f1plot::StintSummary('2019mexico', toFile = T)
savePlot2 = function(file, ...) {
png(file = fileName)
plot(...)
dev.off()
}
savePlot2('c:/temp/test.png', x = 1:10, y = 1:10)
savePlot2 = function(file, ...) {
png(filename = file)
plot(...)
dev.off()
}
savePlot2('c:/temp/test.png', x = 1:10, y = 1:10)
savePlot
devtools::load_all('f1plot')
StintSummary('2019mexico', toFile = T)
devtools::load_all('f1plot')
StintSummary('2019mexico', toFile = T)
PlotTyreDeg()
PlotTyreDeg('2019mexico')
myRace = '2019mexico'
myTyreDF = raceTyreDF %>%
filter(race == myRace & isValidTyre30) %>%
select(tyre, mod30TyreInt, mod30TyreSlope)
fastestNewTyre = with(myTyreDF, tyre[near(mod30TyreInt, 0)])
stintLength = 30
tyreWearDF = left_join(expand.grid(tyre = myTyreDF$tyre,
tyreLap = 0:(stintLength - 1),
stringsAsFactors = FALSE),
myTyreDF,
'tyre')
tyreWearDF
raceTyreDF %>% filter(race == myRace)
devtools::load_all('f1plot')
PlotTyreDeg('2019mexico')
f1data:::ViewLap('2019mexico', 4)
f1data:::ViewLap('2019mexico', 5)
PlotTyreDeg('2019mexico', toFile = T)
f1plot::DriverRacePlot('2019mexico','sperez','dricciardo')
f1plot::DriverRacePlot('2019mexico','sperez',includeAdjustedTime = T)
ReadF1Data(paste0(OUTPUTPATH, team-colour.csv))
ReadF1Data('paste0(OUTPUTPATH, team-colour.csv'), 'teamColour')
ReadF1Data(paste0(OUTPUTPATH, team-colour.csv'), 'teamColour')
ReadF1Data(paste0(OUTPUTPATH, 'team-colour.csv'), 'teamColour')
devtools::load_all('f1plot')
DriverRacePlot('2019mexico','sperez')
DriverRacePlot('2019mexico','sperez', includeAdjustedTime = T)
DriverRacePlot('2019mexico','dricciardo', includeAdjustedTime = T)
DriverRacePlot('2019mexico','mverstappen', 'aalbon')
DriverRacePlot('2019mexico','mverstappen', 'aalbon', toFile = TRUE)
